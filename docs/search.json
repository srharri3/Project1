[
  {
    "objectID": "Project1.html",
    "href": "Project1.html",
    "title": "ST 558 | Project 1 | Team N",
    "section": "",
    "text": "This project demonstrates the use of R for collecting, processing, and studying US Census data via its API. The data processing functions will allow a variety of fields to be pulled or subset, via their arguments. Data summary functions will auto-summarize and auto-plot the returned data. Lastly, we add commentary and analysis of some points of interest."
  },
  {
    "objectID": "Project1.html#api-resources",
    "href": "Project1.html#api-resources",
    "title": "ST 558 | Project 1 | Team N",
    "section": "API Resources",
    "text": "API Resources\n\nInformation about the PUMS API\nVariable list (2022)\nAPI call examples\nMenu-based API call explorer\nSample API call: api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24&key=YOUR_KEY"
  },
  {
    "objectID": "Project1.html#api-fields",
    "href": "Project1.html#api-fields",
    "title": "ST 558 | Project 1 | Team N",
    "section": "API Fields",
    "text": "API Fields\nPer the syllabus, our functions will accommodate retrieval of the following fields.\n\nYear of survey\n\nDefault:\n\n2022\n\nValid:\n\nInteger in [2010,2022]\n\nConditions:\n\nIn query function, only one year is accessed per query. Multiple years will be looped with multiple calls.\n\n\nNumeric var(s)\n\nDefault:\n\nAGEP\nPWGTP (always)\n\nValid:\n\nAGEP\nGASP\nGRPIP\nJWAP (time)\nJWDP (time)\nJWMNP\n\nConditions:\n\nTranslate variables to numeric or time (middle of period) as applicable.\nPWGTP and at least one additional numeric var must be returned.\nEnsure valid user entries.\n\n\nCategorical var(s)\n\nDefault:\n\nSEX\n\nValid:\n\nFER\nHHL\nHISPEED\nJWTRNS\nSCH\nSCHL\nSEX\n\nConditions:\n\nTranslate variables into factors with appropriate levels as applicable.\nAt least one categorical variable must be returned.\nEnsure valid user entries.\n\n\nGeography level\n\nDefault:\n\nAll\n\nValid:\n\nAll\nRegion\nDivision\nState\n\nConditions:\n\nOne selection only.\nEnsure valid user entries.\n\n\nGeography subsets\n\nDefault:\n\n17\n\nValid:\n\nN/A (no error checking provided)\n\nConditions:\n\nUser can specify specific Regions, Divisions, or States.\nOnly specific levels selected will be returned."
  },
  {
    "objectID": "Project1.html#plan",
    "href": "Project1.html#plan",
    "title": "ST 558 | Project 1 | Team N",
    "section": "Plan",
    "text": "Plan\nWe will follow these steps to develop our data processing functions.\n\nBegin by testing a sample API call.\nDevelop a helper function to process results from GET() into a useful tibble.\nDevelop a function to build and query the API according to user parameters, for one year.\nDevelop a function to process the API results into proper variable types and factors.\nDevelop a function to allow for multi-year query handling, processing the result into a single tibble.\n\nNote that if syntax changes or limitations exist for certain years of data (for instance, say ‘HISPEED’ was not available in year X), requests may fail. All functions are tested and validated for the 2022 API endpoint, at a minimum."
  },
  {
    "objectID": "Project1.html#libraries",
    "href": "Project1.html#libraries",
    "title": "ST 558 | Project 1 | Team N",
    "section": "Libraries",
    "text": "Libraries\nLoading necessary libraries for API processing and tidyverse functions.\n\n#to help with parsing contents of API calls\nlibrary(jsonlite)\n\n#for API URL building\nlibrary(httr)\n\n#for tidy stuff\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(magrittr)\nlibrary(tidyr)\n\n\nAttaching package: 'tidyr'\n\n\nThe following object is masked from 'package:magrittr':\n\n    extract\n\nlibrary(RSQLite)\n\n#for string manipulations, esp time formatting\nlibrary(stringr)\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union"
  },
  {
    "objectID": "Project1.html#sample-api-test",
    "href": "Project1.html#sample-api-test",
    "title": "ST 558 | Project 1 | Team N",
    "section": "Sample API Test",
    "text": "Sample API Test\nBefore we build functions, let’s just make a simple call to ensure we understand how to build the query and process its results.\nWe will call this sample URL: https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR,ST&SCHL=24\n\n#build URL\ntest_URL &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR,ST&SCHL=24\"\n\n#get url\ntest_results &lt;- GET(test_URL)\n\n#pull content JSON branch and convert to char\ntest_parsed_content &lt;- fromJSON(rawToChar(test_results$content))\n\n#convert to tibble\ntest_tibble &lt;- as_tibble(test_parsed_content)\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n#display test\ntest_tibble\n\n# A tibble: 44,080 × 5\n   V1    V2    V3    V4    V5   \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 SEX   PWGTP MAR   ST    SCHL \n 2 2     6     5     17    24   \n 3 2     23    2     06    24   \n 4 1     23    3     42    24   \n 5 1     80    5     49    24   \n 6 1     16    1     18    24   \n 7 1     107   3     18    24   \n 8 2     10    5     13    24   \n 9 1     22    1     39    24   \n10 2     127   5     32    24   \n# ℹ 44,070 more rows\n\n\nSuccess!"
  },
  {
    "objectID": "Project1.html#helper-functions",
    "href": "Project1.html#helper-functions",
    "title": "ST 558 | Project 1 | Team N",
    "section": "Helper Functions",
    "text": "Helper Functions\n\nFcn: Get Lookup [Table]\nIn order to process API results into proper variable types and factors, we use this helper function to pull the lookup table for a provided variable.\n\n# function:\n#   getLookup(varName,year=2022)\n\n# purpose:\n#   Format and call API to get variable lookup data. Returns a 2-column tibble of keys and labels.\n#   Sample data dictionary call: https://api.census.gov/data/YEAR/acs/acs1/pums/variables/VARNAME.json\n\n# arguments: \n#   varName - the variable we want to pull\n#   year - the year of the data dictionary to pull (default 2022)\n\n# returns: \n#   2-column tibble of keys and labels.\n\n# error handling: \n#   none!!\n\ngetLookup &lt;- function(varName, year=2022) {\n  \n  #prepare API dictionary call\n  lookup_URL_base1 &lt;- 'https://api.census.gov/data/'\n  lookup_URL_base2 &lt;- '/acs/acs1/pums/variables/'\n  lookup_URL_suffix &lt;- '.json'\n  lookup_URL &lt;- paste(lookup_URL_base1,\n                      year,\n                      lookup_URL_base2,\n                      varName,\n                      lookup_URL_suffix,\n                      sep = '',\n                      collapse = '')\n  \n  #pull result and get tibble, keep only the values/items\n  lookup_URL_result &lt;- GET(lookup_URL) |&gt; getToTibble()\n  \n  #keep only the needed parts in values:item, order by keys\n  lookup_valuesItem &lt;- lookup_URL_result$values$item\n  lookup_list &lt;- lookup_valuesItem[sort(names(lookup_valuesItem))]\n  \n  #format as a long tibble\n  lookup_tibble &lt;- lookup_list |&gt; as_tibble() |&gt; pivot_longer(cols=everything())\n  \n  #return long, 2-column tibble\n  return(lookup_tibble)\n  \n}\n\n\n\nFcn: Check Year\nThis function takes an argument of year and returns TRUE if it is valid for our project.\nValid arguments: A single year in the range [2010,2022]\n\n# function:\n#   checkYear(year)\n\n# purpose:\n#   Confirm that passed integer value is within [2010,2022].\n\n# arguments: \n#   year - the year to check\n\n# returns: \n#   TRUE for successful validation, FALSE else (including error)\n\n# error handling: \n#   FALSE for non-integer\n\ncheckYear &lt;- function(year) {\n\n  validation &lt;- case_when(\n    year%%1 != 0 ~ FALSE, #non-int = FALSE\n    year &lt; 2010 ~ FALSE,  #below 2010 = FALSE\n    year &gt; 2022 ~ FALSE,  #over 2022 = FALSE\n    TRUE ~ TRUE           #else = TRUE\n  )\n  \n  return(validation)\n  \n}\n\n\n\nFcn: Check Num[eric] Vars\nThis function takes an argument of a vector of characters representing the set of numeric variables being requested. It validates them and returns TRUE if the entire set is valid.\nValid arguments: 1+ strings only from the set [AGEP,GASP,GRPIP,JWAP,JWDP,JWMNP,PWGTP]\n\n# function:\n#   checkNumVars(vars)\n\n# purpose:\n#   Confirm that numeric variable names passed are within the legitimate set.\n\n# arguments: \n#   vars - vector of chars\n\n# returns: \n#   TRUE if all elements pass validation, FALSE else\n\n# error handling: \n#   none!!\n\ncheckNumVars &lt;- function(vars) {\n\n  #init validation. If it remains TRUE, validation successful.\n  validation &lt;- TRUE\n  \n  #cycle through all values in the vector\n  for (var_i in vars) {\n    \n    #if value of element not in list, toggle validation to FALSE\n    if (!(var_i %in% c('AGEP',\n                       'GASP',\n                       'GRPIP',\n                       'JWAP',\n                       'JWDP',\n                       'JWMNP',\n                       'PWGTP')))\n      validation &lt;- FALSE\n  }\n  \n  return(validation)\n}\n\n\n\nFcn: Check Cat[egorical] Vars\nThis function takes an argument of a vector of characters representing the set of categorical variables being requested. It validates them and returns TRUE if the entire set is valid.\nValid arguments: 1+ strings only from the set [SEX,FER,HHL,HISPEED,JWTRNS,SCH,SCHL]\n\n# function:\n#   checkCatVars(vars)\n\n# purpose:\n#   Confirm that categorical variable names passed are within the legitimate set.\n\n# arguments: \n#   vars - vector of chars\n\n# returns: \n#   TRUE if all elements pass validation, FALSE else\n\n# error handling: \n#   none!!\n\ncheckCatVars &lt;- function(vars) {\n\n  #init validation. If it remains TRUE, validation successful.\n  validation &lt;- TRUE\n  \n  #cycle through all values in the vector\n  for (var_i in vars) {\n    \n    #if value of element not in list, toggle validation to FALSE\n    if (!(var_i %in% c('SEX',\n                       'FER',\n                       'HHL',\n                       'HISPEED',\n                       'JWTRNS',\n                       'SCH',\n                       'SCHL')))\n      validation &lt;- FALSE\n  }\n  \n  return(validation)\n}\n\n\n\nFcn: Check Geo[graphy Level]\nThis function takes an argument of a character string representing the geography level for subsetting. It validates the requested type is within the accepted list, returning TRUE if so.\nValid arguments: A string from the set [All,Region,Division,State]\n\n# function:\n#   checkGeo(geoLevel)\n\n# purpose:\n#   Confirm that geography level is a single string within legitimate set.\n\n# arguments: \n#   geoLevel - string\n\n# returns: \n#   TRUE if element passes validation, FALSE else\n\n# error handling: \n#   FALSE if vector length is beyond 1 string\n\ncheckGeo &lt;- function(geoLevel) {\n  \n  #set FALSE if longer than 1 or out of bounds\n  if (length(geoLevel) != 1) \n    \n    validation = FALSE\n  \n  else if (geoLevel %in% c('All',\n                           'Region',\n                           'Division',\n                           'State'))\n    \n    validation = TRUE\n  \n  else\n    \n    validation = FALSE\n  \n  #TRUE if valid\n  return(validation)\n}"
  },
  {
    "objectID": "Project1.html#main-functions",
    "href": "Project1.html#main-functions",
    "title": "ST 558 | Project 1 | Team N",
    "section": "Main Functions",
    "text": "Main Functions\n\nFcn: [From] GET to Tibble\nNow, let’s develop the helper function to process results from GET() into a useful tibble.\n\n# function:\n#   getToTibble(get_results)\n\n# purpose:\n#   Take results from a Census GET call, which come back with raw JSON, and transform them into a usable tibble that shows only the retrieved content in a friendly format.\n\n# arguments: \n#   get_results - the result of a prior call to GET() on the Census API\n\n# returns: \n#   tibble corresponding to the parsed, json, raw to char 'content' element of the original GET result\n\n# error handling: \n#   none!!\n\ngetToTibble &lt;- function(get_results) {\n  \n  #pull content JSON branch and convert to char\n  parsed_results &lt;- fromJSON(rawToChar(get_results$content))\n  \n  #convert to tibble\n  tibble_results = as_tibble(parsed_results)  \n\n  #return tibble\n  return(tibble_results)\n}\n\nLet’s confirm that our function produces the same result as our earlier manual API call.\n\ngetToTibble(test_results)\n\n# A tibble: 44,080 × 5\n   V1    V2    V3    V4    V5   \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 SEX   PWGTP MAR   ST    SCHL \n 2 2     6     5     17    24   \n 3 2     23    2     06    24   \n 4 1     23    3     42    24   \n 5 1     80    5     49    24   \n 6 1     16    1     18    24   \n 7 1     107   3     18    24   \n 8 2     10    5     13    24   \n 9 1     22    1     39    24   \n10 2     127   5     32    24   \n# ℹ 44,070 more rows\n\n\nSuccess!\n\n\nFcn: Query [the] Census [API]\nDeveloping a function to build and query the API according to user parameters is complex.\nIt requires a good deal of error checking to ensure valid field names. Helper functions will be used for validating parameters. Defaults will exist for parameters, including a default to subset by State = 17 Illinois/IL to keep data sizes manageable (unless otherwise specified in the function call).\nFor a reminder of valid fields, consult the previous section on API Fields.\n\n# function:\n#   queryCensus(year=2022,numVars=c('AGEP','PWGTP'),catVars='SEX',geoLevel='All',geoSubset=17)\n\n# purpose:\n#   Build and call the Census API, returning NA if invalid or the result of the correct GET call.\n\n# arguments: \n#   year - year to query\n#   numVars - vector of chars, 1 or more\n#   catVars - vector of chars, 1 or more\n#   geoLevel - one string matching permitted values\n#   geoSubset - vector of chars, 1 or more, for subset by geoLevel (no restrictions)\n\n# returns: \n#   NA if even one parameter is invalid, else the result of the GET call\n\n# error handling: \n#   NA if any parameter is invalid\n\nqueryCensus &lt;- function(year = 2022,\n                        numVars = c('AGEP','PWGTP'),\n                        catVars = 'SEX',\n                        geoLevel = 'All',\n                        geoSubset = 17 ) { \n\n  #validate arguments\n  status &lt;- checkYear(year) &\n            checkNumVars(numVars) &\n            checkCatVars(catVars) &\n            checkGeo(geoLevel)\n  #if any of these failed, status is now FALSE and exit returning NA\n  if (!status) \n    return(NA)\n  \n  #ensure numVars includes 'PWGTP' required variable\n  if ( !('PWGTP' %in% numVars) ) { numVars &lt;- c(numVars,'PWGTP') }\n  \n  #otherwise, proceed and combine strings appropriately for query parameters\n\n  #combine numeric and categorical vars for the get parameter\n  get_param &lt;- paste(paste(numVars,sep = ',',collapse = ','),\n                     ',',\n                     paste(catVars,sep = ',',collapse = ','),\n                     sep = '',\n                     collapse = ''\n  )\n  \n  #since geo level passed validation, only need to switch 'All' for 'State' if applicable\n  geoLevelCode &lt;- if(geoLevel == 'All') 'State' else geoLevel\n  \n  #prepare subset strings\n  subset_param &lt;- paste(paste(geoSubset,sep = ',',collapse = ','),\n                        sep = '',\n                        collapse = ''\n                        )\n  \n  ###############\n  #this is how to do the state stuff\n  #can remove all the 'ST' garbage above\n  #https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR,ST&SCHL=24&for=state:13,14,15,16,17&SCHL=24\n  \n  \n  \n  #base URL for example: api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24&key=YOUR_KEY\n  #build and call API\n  base_URL1 &lt;- \"https://api.census.gov/data/\"\n  base_URL2 &lt;- \"/acs/acs1/pums?\"\n  query_URL &lt;- paste(base_URL1,\n                     year,\n                     base_URL2,\n                     'get=',\n                     get_param,\n                     '&for=',\n                     geoLevelCode,\n                     ':',\n                     subset_param,\n                     sep = '',\n                     collapse = '')\n  \n  #display the final URL for helpful reference\n  print(query_URL)\n  \n  #run query and return GET results\n  query_results &lt;- GET(query_URL)\n  \n  return(query_results)\n}\n\n\n\nFcn: Format [API] Results\nWe need to adjust numeric fields from char to num/time and replace enumerated categorical field values with representative labels in our tibble. For instance, ‘HISPEED’ has three values 0,1,2 which correspond to N/A, Yes, No. \nWe need to transform each column according to its type and lookup values. Also, we take the header names from row 1 into the column labels, removing row 1.\n\n# function:\n#   formatResults(results,year=2022)\n\n# purpose:\n#   Replace columns of the tibble with appropriate type and values. Also fix column labels/header.\n\n# arguments: \n#   results - tibble of Census results\n#   year - year to query\n\n# returns: \n#   Adjusted, formatted tibble\n\n# error handling: \n#   none!!\n\nformatResults &lt;- function(results,year=2022) {\n  \n  #if year is a field, get ready to swap it back\n  if ('Year' %in% names(results))\n    year_on &lt;- TRUE\n  else\n    year_on &lt;- FALSE\n  \n  #update the column names from row1\n  names(results) &lt;- results[1,]\n  \n  #fix year if needed\n  if (year_on) attributes(results)$names[length(results)] &lt;- 'Year'\n  \n  #remove row1\n  results &lt;- results[-1,]\n  \n  #vector of all possible GET variables that may require revision\n  all_variables = c('AGEP', #NUMERICS\n                    'PWGTP',\n                    'GASP',\n                    'GRPIP',\n                    'JWMNP',\n                    'JWAP', #TIME\n                    'JWDP',\n                    'SEX', #CATEGORICAL\n                    'FER',\n                    'HHL',\n                    'HISPEED',\n                    'JWTRNS',\n                    'SCH',\n                    'SCHL',\n                    'Region',\n                    'Division',\n                    'State')\n  \n  #vectors of all possible variables by types\n  numeric_variables = c('AGEP',\n                        'PWGTP',\n                        'GASP',\n                        'GRPIP',\n                        'JWMNP')\n  time_variables = c('JWAP',\n                     'JWDP')\n  cat_variables = c('SEX',\n                    'FER',\n                    'HHL',\n                    'HISPEED',\n                    'JWTRNS',\n                    'SCH',\n                    'SCHL',\n                    'Region',\n                    'Division',\n                    'State')\n  \n  #loop through all possible vars requiring update\n  #if it exists in our tibble as a column, revise the column type appropriately\n  for (varName in all_variables) {\n  \n    #loop through all columns in tibble\n    for (colName in names(results)) {\n\n      #if a match \n      if (varName == colName) {\n        \n        #for a numeric OR time type, first swap its contents to numeric\n        if ((varName %in% numeric_variables) | (varName %in% time_variables)) {\n          results[varName] &lt;- as.numeric(results[[varName]])\n        }\n        \n        #for a time type, parse the lookup results to get start,end\n        #then set to midway as time format\n        if (varName %in% time_variables) {\n          \n          #pull lookup\n          lookup &lt;- getLookup(varName,year)\n          \n          #make lookup 'name' column into a numeric for matching\n          lookup$name &lt;- as.numeric(lookup$name)\n          \n          #make a temp join but only keep the replaced char labels in the result column\n          temp &lt;- results[varName]\n          names(temp) &lt;- 'name'\n          temp_join &lt;- left_join(temp,lookup,by=join_by(name == name))\n        \n          #get start and end times\n          #ltime &lt;- word(temp_join$value,1)\n          #lampm &lt;- word(temp_join$value,2)\n          #ltimepm &lt;- if_else(lampm==\"p.m.\",12,0)\n          #rtime &lt;- word(temp_join$value,4)\n          #rampm &lt;- word(temp_join$value,5)\n          #rtimepm &lt;- if_else(rampm==\"p.m.\",12,0)\n\n          #prepare times in another column\n          #temp_join$lhour &lt;- word(ltime,1,sep=\":\")# + lampm\n          #temp_join$lhour &lt;- temp_join$lhour\n          #temp_join$lminute &lt;- word(ltime,2,sep=\":\")\n          #temp_join$rhour &lt;- word(rtime,1,sep=\":\")# + rampm\n          #temp_join$rminute &lt;- word(rtime,2,sep=\":\")\n          #temp_join$diffhour &lt;- as_temp_join$rhour-temp_join$lhour\n          #temp_join$diffminute &lt;- temp_join$rminute-temp_join$lminute\n          \n          #for only rows where it was a time\n          #adjust the format\n          #temp_join$value[temp_join$value %in% c(\"a.m.\",\"p.m.\")] &lt;-\n          #  hms(hours = floor(temp_join$lhour+(temp_join$diffhour/2)),\n          #      minutes = floor(temp_join$lminute+(temp_join$diffminute/2)))\n          \n          #adjust value\n          results[varName]&lt;- temp_join$value\n        }\n        \n\n        \n        #for a categ type, swap its contents from index to label \n        if (varName %in% cat_variables) {\n\n          #pull lookup table for cat var\n          #special handling if 'State' because that has to lookup using \"ST\"\n          if(varName=='State')\n            lookup &lt;- getLookup('ST',year)\n          else\n            lookup &lt;- getLookup(varName,year)\n          \n          #make a temp join but only keep the replaced char labels in the result column\n          temp &lt;- results[varName]\n          names(temp)='name'\n          temp_join &lt;- left_join(temp,lookup,by=join_by(name == name))\n\n          #revise values \n          results[varName] &lt;- temp_join$value\n        }\n                                      \n      }\n      \n    }\n    \n  }\n  \n  #special handling for geo lookup, because in function call previously it doesn't like it \n  if(\"region\" %in% names(results)) {\n    geoLevel &lt;- \"region\"\n    geoLevel_query &lt;- \"REGION\"\n  }\n  else if(\"division\" %in% names(results)) {\n    geoLevel &lt;- \"division\"\n    geoLevel_query &lt;- \"DIVISION\"\n  }\n  else {\n    geoLevel &lt;- \"state\"\n    geoLevel_query &lt;- \"ST\"\n  }\n  \n  #pull lookup table for geo field\n  lookup &lt;- getLookup(geoLevel_query,year)\n  \n  #make a temp join but only keep the replaced char labels in the result column\n  temp2 &lt;- results[geoLevel]\n  names(temp2)='name'\n  temp2_join &lt;- left_join(temp2,lookup,by=join_by(name == name))\n  \n  #revise values \n  results[geoLevel] &lt;- temp2_join$value\n  \n  #return revised tibble\n  return(results)\n}\n\n\n\nFcn: Query Multiple Years\nThis final function will take a set of 1+ years, loop through calls to query the Census on each year endpoint, then combine and format and return a single tibble!\n\n# function:\n#   queryMultipleYears(years=c(2022),numVars,catVars,geoLevel,geoSubset)\n\n# purpose:\n#   Loop through calls to get query for each year, then combine and format, and return the final single tibble of data. Year is a column added to the results of each query.\n\n# arguments: \n#   years - vector of numeric indicating each year of interest\n#   numVars - vector of chars, 1 or more\n#   catVars - vector of chars, 1 or more\n#   geoLevel - one string matching permitted values\n#   geoSubset - vector of chars, 1 or more, for subset by geoLevel (no restrictions)\n\n# returns: \n#   Complete, consolidated, formatted tibble\n\n# error handling: \n#   none!!\n\nqueryMultipleYears &lt;- function(years=c(2022),numVars=c('AGEP','PWGTP'),catVars=c('SEX'),geoLevel='State',geoSubset=17) {\n  \n  #init large_tibble\n  large_tibble &lt;- tibble()\n  \n  #loop through all years in vector\n  for (years_i in years) {\n    \n    #query the api\n    results_query_i &lt;- queryCensus(years_i,numVars,catVars)#,geoLevel,geoSubset)\n    \n    #translate to a tibble\n    tibble_query_i &lt;- getToTibble(results_query_i)\n    \n    #append the year variable\n    tibble_query_i['Year'] &lt;- years_i\n    \n    #add to large tibble\n    large_tibble &lt;- bind_rows(large_tibble,tibble_query_i)\n    \n  }\n  \n  #format\n  large_tibble_formatted &lt;- formatResults(large_tibble)\n  \n  #remove any NA rows which happened due to headers in every query\n  large_tibble_formatted &lt;- filter(large_tibble_formatted,!is.na(large_tibble_formatted[[1]]))\n  \n  #return\n  return(large_tibble_formatted)\n}\n\n-   Conditions:\n    -   Call single year function repeatedly as needed.\n    -   Combine data into one final tibble, including `year` variable."
  },
  {
    "objectID": "Project1.html#validate-custom-query-function-1yr",
    "href": "Project1.html#validate-custom-query-function-1yr",
    "title": "ST 558 | Project 1 | Team N",
    "section": "Validate Custom Query Function (1yr)",
    "text": "Validate Custom Query Function (1yr)\nNow, let’s run some sample calls. First, a call with no arguments, relying solely on defaults.\n\ntest_results &lt;- getToTibble(queryCensus())\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX&for=State:17\"\n\ntest_results\n\n# A tibble: 128,047 × 4\n   V1    V2    V3    V4   \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 AGEP  PWGTP SEX   state\n 2 82    32    2     17   \n 3 43    91    1     17   \n 4 18    45    2     17   \n 5 49    38    1     17   \n 6 42    8     1     17   \n 7 83    7     1     17   \n 8 88    6     2     17   \n 9 23    59    2     17   \n10 56    64    2     17   \n# ℹ 128,037 more rows\n\n\nSuccess! Next, let’s try every possible parameter. For simplicity, we will use State=17.\n\ntest_results &lt;- getToTibble(\n  queryCensus(2022,\n              catVars=c('SEX','HISPEED','FER','HHL','JWTRNS','SCH','SCHL'),\n              geoLevel='State',\n              geoSubset = 17,\n              numVars=c('AGEP','PWGTP','GASP','GRPIP','JWAP','JWDP','JWMNP'))\n)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,GASP,GRPIP,JWAP,JWDP,JWMNP,SEX,HISPEED,FER,HHL,JWTRNS,SCH,SCHL&for=State:17\"\n\ntest_results\n\n# A tibble: 128,047 × 15\n   V1    V2    V3    V4    V5    V6    V7    V8    V9    V10   V11   V12   V13  \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 AGEP  PWGTP GASP  GRPIP JWAP  JWDP  JWMNP SEX   HISP… FER   HHL   JWTR… SCH  \n 2 82    32    3     0     0     0     0     2     0     0     0     0     1    \n 3 43    91    3     0     0     0     0     1     0     0     0     0     1    \n 4 18    45    3     0     0     0     0     2     0     2     0     11    2    \n 5 49    38    3     0     0     0     0     1     0     0     0     0     1    \n 6 42    8     3     0     0     0     0     1     0     0     0     0     1    \n 7 83    7     3     0     0     0     0     1     0     0     0     0     1    \n 8 88    6     3     0     0     0     0     2     0     0     0     0     1    \n 9 23    59    3     0     90    49    10    2     0     2     0     1     3    \n10 56    64    3     0     0     0     0     2     0     0     0     0     1    \n# ℹ 128,037 more rows\n# ℹ 2 more variables: V14 &lt;chr&gt;, V15 &lt;chr&gt;\n\n\nSuccess! Now, let’s apply the formatting function to replace categorical enumerated elements, make numeric columns into numeric type, and fix column names.\n\ntest_results_formatted &lt;- formatResults(test_results)\n\nWarning: The `value` argument of `names&lt;-()` must be a character vector as of tibble\n3.0.0.\n\ntest_results_formatted\n\n# A tibble: 128,046 × 15\n    AGEP PWGTP  GASP GRPIP JWAP     JWDP  JWMNP SEX   HISPEED FER   HHL   JWTRNS\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; \n 1    82    32     3     0 N/A (no… N/A …     0 Fema… N/A (G… N/A … N/A … N/A (…\n 2    43    91     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … N/A (…\n 3    18    45     3     0 N/A (no… N/A …     0 Fema… N/A (G… No    N/A … Worke…\n 4    49    38     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … N/A (…\n 5    42     8     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … N/A (…\n 6    83     7     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … N/A (…\n 7    88     6     3     0 N/A (no… N/A …     0 Fema… N/A (G… N/A … N/A … N/A (…\n 8    23    59     3     0 7:40 a.… 7:30…    10 Fema… N/A (G… No    N/A … &lt;NA&gt;  \n 9    56    64     3     0 N/A (no… N/A …     0 Fema… N/A (G… N/A … N/A … N/A (…\n10    21     9     3     0 1:10 p.… 12:3…    40 Fema… N/A (G… No    N/A … Walked\n# ℹ 128,036 more rows\n# ℹ 3 more variables: SCH &lt;chr&gt;, SCHL &lt;chr&gt;, state &lt;chr&gt;\n\n\nSuccess!"
  },
  {
    "objectID": "Project1.html#validate-multi-year-query-function",
    "href": "Project1.html#validate-multi-year-query-function",
    "title": "ST 558 | Project 1 | Team N",
    "section": "Validate Multi-Year Query Function",
    "text": "Validate Multi-Year Query Function\nLastly, let’s call the function for multi-year results in a single tibble. Start simple with defaults, first.\n\nmulti_test_tibble &lt;- queryMultipleYears(years=c(2021,2022))\n\n[1] \"https://api.census.gov/data/2021/acs/acs1/pums?get=AGEP,PWGTP,SEX&for=State:17\"\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX&for=State:17\"\n\n\nWarning in formatResults(large_tibble): NAs introduced by coercion\nWarning in formatResults(large_tibble): NAs introduced by coercion\n\nmulti_test_tibble\n\n# A tibble: 254,669 × 5\n    AGEP PWGTP SEX    state        Year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;       &lt;dbl&gt;\n 1    37   104 Male   Illinois/IL  2021\n 2    48    29 Female Illinois/IL  2021\n 3    66    19 Female Illinois/IL  2021\n 4    51    84 Male   Illinois/IL  2021\n 5    86     4 Male   Illinois/IL  2021\n 6    32    86 Male   Illinois/IL  2021\n 7    61    30 Female Illinois/IL  2021\n 8    50    38 Female Illinois/IL  2021\n 9    74     6 Female Illinois/IL  2021\n10    36     8 Male   Illinois/IL  2021\n# ℹ 254,659 more rows\n\n\nSuccess! Now, once more with all variables and a third year.\n\nmulti_test_tibble_2 &lt;- queryMultipleYears(years=c(2019,2021,2022),\n                                          catVars=c('SEX','HISPEED','FER','HHL','JWTRNS','SCH','SCHL'),\n                                          geoLevel='State',\n                                          geoSubset = 17,\n                                          numVars=c('AGEP','PWGTP','GASP','GRPIP','JWAP','JWDP','JWMNP') )\n\n[1] \"https://api.census.gov/data/2019/acs/acs1/pums?get=AGEP,PWGTP,GASP,GRPIP,JWAP,JWDP,JWMNP,SEX,HISPEED,FER,HHL,JWTRNS,SCH,SCHL&for=State:17\"\n[1] \"https://api.census.gov/data/2021/acs/acs1/pums?get=AGEP,PWGTP,GASP,GRPIP,JWAP,JWDP,JWMNP,SEX,HISPEED,FER,HHL,JWTRNS,SCH,SCHL&for=State:17\"\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,GASP,GRPIP,JWAP,JWDP,JWMNP,SEX,HISPEED,FER,HHL,JWTRNS,SCH,SCHL&for=State:17\"\n\n\nWarning in formatResults(large_tibble): NAs introduced by coercion\nWarning in formatResults(large_tibble): NAs introduced by coercion\nWarning in formatResults(large_tibble): NAs introduced by coercion\nWarning in formatResults(large_tibble): NAs introduced by coercion\nWarning in formatResults(large_tibble): NAs introduced by coercion\nWarning in formatResults(large_tibble): NAs introduced by coercion\nWarning in formatResults(large_tibble): NAs introduced by coercion\n\nmulti_test_tibble_2\n\n# A tibble: 379,676 × 16\n    AGEP PWGTP  GASP GRPIP JWAP     JWDP  JWMNP SEX   HISPEED FER   HHL   JWTRNS\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; \n 1    22   179     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … Worke…\n 2    53     3     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … Worke…\n 3    35    87     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … N/A (…\n 4    42    93     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … N/A (…\n 5    18    61     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … N/A (…\n 6    58     4     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … Worke…\n 7    61     6     3     0 N/A (no… N/A …     0 Fema… N/A (G… N/A … N/A … N/A (…\n 8    61    19     3     0 N/A (no… N/A …     0 Male  N/A (G… N/A … N/A … N/A (…\n 9    78    11     3     0 N/A (no… N/A …     0 Fema… N/A (G… N/A … N/A … N/A (…\n10    19    92     3     0 N/A (no… N/A …     0 Fema… N/A (G… No    N/A … N/A (…\n# ℹ 379,666 more rows\n# ℹ 4 more variables: SCH &lt;chr&gt;, SCHL &lt;chr&gt;, state &lt;chr&gt;, Year &lt;dbl&gt;\n\n\nSuccess! Wow!"
  },
  {
    "objectID": "Project1.html#creating-summary-function",
    "href": "Project1.html#creating-summary-function",
    "title": "ST 558 | Project 1 | Team N",
    "section": "Creating Summary Function",
    "text": "Creating Summary Function\n\n#Creating summary function, setting default to NULL so it will take in all variables\nsummary.census &lt;- function(test_results_formatted, numVars = NULL, catVars= NULL) {\n#Pulling the numeric variables from the test_results_formatted tibble, without including PWGTP\n  if(is.null(numVars)) {\n   numVars &lt;- names(select(test_results_formatted, where(is.numeric), -PWGTP))\n  }\n#Pulling the categorical variables from the test_results_formatted tibble\n  if(is.null(catVars)) {\n    catVars &lt;- names(select(test_results_formatted, -where(is.numeric)))\n  }\n  \n#Calculating the sample mean for the numeric variables\n  numeric_summary1 &lt;-\n  test_results_formatted |&gt;\n    summarize(across(all_of(numVars),\n                    list(mean = ~ sum(. * PWGTP, na.rm = TRUE) / sum(PWGTP, na.rm =TRUE)),\n                     .names = \"{.col}_mean\"))\n      \n#Calculating the standard deviation for the numeric variables        \n  numeric_summary2 &lt;-\n  test_results_formatted |&gt;\n    summarize(across(all_of(numVars),\n       list(sd = ~ sqrt(sum(.^2 * PWGTP, na.rm = TRUE) / (sum(PWGTP, na.rm = TRUE) - (sum(. * PWGTP, na.rm = TRUE) / sum(PWGTP, na.rm = TRUE))^2))),\n                     .names = \"{.col}_sd\"))\n#Counting the categorical variables\n  cat_count &lt;-\n  test_results_formatted |&gt;\n    drop_na(all_of(catVars)) |&gt; \n  group_by(across(all_of(catVars))) |&gt;\n          summarize(count = n(), .groups = \"drop\")\n\n#Returning values from the function as a list\nreturn(list(mean_summary = numeric_summary1, sd_summary = numeric_summary2, categorial_count = cat_count))\n\n}\n\nTesting the summary function.\n\nsummary_result &lt;- summary(test_results_formatted, \"JWMNP\",\"SEX\")\nsummary_result\n\n$mean_summary\n# A tibble: 1 × 1\n  JWMNP_mean\n       &lt;dbl&gt;\n1       11.6\n\n$sd_summary\n# A tibble: 1 × 1\n  JWMNP_sd\n     &lt;dbl&gt;\n1     23.1\n\n$categorial_count\n# A tibble: 2 × 2\n  SEX    count\n  &lt;chr&gt;  &lt;int&gt;\n1 Female 65326\n2 Male   62720"
  },
  {
    "objectID": "Project1.html#creating-boxplot-function",
    "href": "Project1.html#creating-boxplot-function",
    "title": "ST 558 | Project 1 | Team N",
    "section": "Creating boxplot function",
    "text": "Creating boxplot function\nLoading in ggplot2 package\n\nlibrary(ggplot2)\n\nCreating the boxplot function for the test_results_formatted tibble\n\nplot.census &lt;- function(df = test_results_formatted, numVars, catVars) {\n   \n  #Pulling the numeric and categorical variables from the test_results_formatted tibble\n  numeric_vars &lt;- names(select(test_results_formatted, where(is.numeric), -PWGTP))\n  categorical_vars &lt;- names(select(test_results_formatted, -where(is.numeric)))\n  \n  #Printing the options for the variables\n  cat(\"Available Numeric Variables:\\n\")\n  print(numeric_vars) \n  cat(\"Available Categorical Variables:\\n\")\n  print(categorical_vars)\n  \n  #Checking to make sure the user put in valid variables names\n  if (!(numVars %in% numeric_vars)) {\n    stop(\"Invalid numeric variable selection. Please choose from available numeric variables.\")\n  }\n  if (!(catVars %in% categorical_vars)) {\n    stop(\"Invalid categorical variable selection. Please choose from available categorical variables.\")\n  }\n  \n  #Creating the boxplot using ggplot\n censusPlot&lt;- ggplot(data = df, mapping = aes(x = get(catVars), y = get(numVars)), weight = PWGTP) + geom_boxplot()+ \n   labs(x = catVars, y = numVars)\n  \n  return(print(censusPlot))\n}\n\nTesting the boxplot function.\n\nplot_census &lt;- plot(df = test_results_formatted, numVars = \"JWMNP\", catVars = \"SEX\")\n\nAvailable Numeric Variables:\n[1] \"AGEP\"  \"GASP\"  \"GRPIP\" \"JWMNP\"\nAvailable Categorical Variables:\n [1] \"JWAP\"    \"JWDP\"    \"SEX\"     \"HISPEED\" \"FER\"     \"HHL\"     \"JWTRNS\" \n [8] \"SCH\"     \"SCHL\"    \"state\""
  }
]